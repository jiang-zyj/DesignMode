在上述的所有单例设计模式中
饿汉式、双重检查、静态内部类、枚举。都是推荐使用的，虽然饿汉式可能会造成内存浪费
但是在实际应用时是没有问题的。
懒汉式中的使用锁来实现也是可以的，但是效率太慢，显然在实际应用中不推荐使用


饿汉式：

    指在类加载时就创建好了对象。
    有两种实现方式：
        第一种是通过静态变量来实例化对象。
        第二种是通过静态代码块来实例化对象。
    优缺点：
        优点：线程安全
        缺点：可能造成内存浪费
    实现步骤：
        1. 构造器私有化
        2. 类的内部创建对象
        3. 向外暴露一个静态的公共方法 getInstance

懒汉式：
    指当类加载时，并没有创建好对象，只有通过调用对应的调用实例方法(这里是通过 getInstance() 方法来实例化对象)
    有三种实现方式：
        第一种是通过调用 getInstance() 方法，再判断 instance(对象) 是否存在，如果存在，获取对象实例
        第二种是通过在方法体上使用 synchronized 关键字，判断 instance(对象) 是否存在，如果存在，则获取对象实例
        第三种是通过在使用 synchronized 关键字来修饰代码块，但与第一种方式一样，并不能解决线程安全。
    第一种方式优缺点：
        优点：实现了懒加载
        缺点：线程不安全
    第二种方式优缺点：
        优点：线程安全
        缺点：使用了 synchronized 关键字，效率太低
    第三种方式优缺点：
        与第一种方式一样，使用同步代码块并不能实现线程安全

双重检查(Double-Check)：
    指进行两次判断，进去前判断一次，进去后判断一次，同时也使用了 synchronized 关键字修饰静态方法和 volatile 关键字修饰静态变量
    优点：线程安全、效率高、同时也实现了懒加载

静态内部类：
    指在类中定义静态内部类，静态内部类在外部类(Singleton类)被加载后，静态内部类并不会被加载，只有在调用静态内部类的相关属性和方法时
    静态内部类才会被加载。
    优点：线程安全(在 JVM 加载类时，线程是安全的)、效率高、同时也实现了懒加载
    缺点：在我个人看来，消耗资源太大了，使用一个类需要编写另一个类，且加大了编码难度

枚举：
    指借助 JDK1.5 提供的枚举来实现单例模式。
    代码：
        enum Singleton {
            INSTANCE;
            public void sayOk() {
                System.out.println("ok");
            }
        }
    优点：线程安全、而且还能防止反序列化重新创建新的对象

单例模式注意事项和细节说明：
    1) 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些
        需要频繁创建销毁的对象，使用单例模式可以提高系统性能
    2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使
        用 new
    3) 单例模式使用的场景：
        需要频繁的进行创建和销毁的对象
        创建对象时耗时过多或耗费资源过多(即重量级对象)，但又经常使用到的对象
        工具类对象
        频繁访问数据库或文件的对象(比如数据源、session工厂等)
